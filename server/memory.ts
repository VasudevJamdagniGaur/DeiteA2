import { neon } from "@neondatabase/serverless";
import { serverDb } from "./firebase-admin";
import {
  collection,
  addDoc,
  query,
  where,
  orderBy,
  getDocs,
  Timestamp,
  doc,
  setDoc,
  getDoc,
  limit,
} from "firebase/firestore";
import { generateSummary } from "./ai";

// PostgreSQL connection
const sql = neon(process.env.DATABASE_URL!);

// ---- Interfaces ----
export interface ChatMessage {
  userId: string;
  role: "user" | "ai";
  content: string;
  timestamp: Date;
  sessionDate: string; // YYYY-MM-DD format
}

export interface LongTermMemory {
  userId: string;
  date: string; // YYYY-MM-DD format
  summary: string;
  createdAt: Date;
}

export interface DayReflection {
  text: string;
  timestamp: Date;
  generated: boolean;
}

// ---- Utility Functions ----
export function getCurrentDateString(): string {
  return new Date().toISOString().slice(0, 10);
}

export function getDateString(date: Date): string {
  return date.toISOString().slice(0, 10);
}

/**
 * Save a chat message using the new Firestore structure:
 * users/{userId}/days/{dayId}/chats/{chatId}
 */
export async function saveMessage(
  userId: string,
  role: "user" | "ai",
  content: string,
): Promise<void> {
  const now = new Date();
  const dayId = getDateString(now);

  try {
    // Save to new structure: users/{userId}/days/{dayId}/chats/{chatId}
    await addDoc(
      collection(serverDb, "users", userId, "days", dayId, "chats"),
      {
        role,
        content,
        timestamp: Timestamp.fromDate(now),
        sessionDate: dayId,
      }
    );

    console.log(`Message saved for user ${userId} on ${dayId}`);
  } catch (error) {
    console.error("Error saving message:", error);
    throw error;
  }
}

/**
 * Get today's messages for a user
 */
export async function getTodaysMessages(userId: string): Promise<ChatMessage[]> {
  const today = getCurrentDateString();
  return getMessagesForDate(userId, today);
}

/**
 * Get messages for a specific date using the new structure
 */
export async function getMessagesForDate(userId: string, date: string): Promise<ChatMessage[]> {
  try {
    const chatsQuery = query(
      collection(serverDb, "users", userId, "days", date, "chats"),
      orderBy("timestamp", "asc")
    );

    const snapshot = await getDocs(chatsQuery);
    return snapshot.docs.map((doc) => {
      const data = doc.data();
      return {
        userId,
        role: data.role,
        content: data.content,
        timestamp: data.timestamp?.toDate ? data.timestamp.toDate() : new Date(data.timestamp),
        sessionDate: date,
      };
    });
  } catch (error) {
    console.error("Error fetching messages for date:", error);
    return [];
  }
}

/**
 * Save day reflection using the new structure:
 * users/{userId}/days/{dayId}/reflections/{reflectionId}
 */
export async function saveDayReflection(
  userId: string,
  date: string,
  reflectionText: string,
  generated: boolean = false
): Promise<void> {
  try {
    await addDoc(
      collection(serverDb, "users", userId, "days", date, "reflections"),
      {
        text: reflectionText,
        timestamp: Timestamp.fromDate(new Date()),
        generated,
      }
    );

    console.log(`Day reflection saved for user ${userId} on ${date}`);
  } catch (error) {
    console.error("Error saving day reflection:", error);
    throw error;
  }
}

/**
 * Get day reflection for a specific date
 */
export async function getDayReflection(userId: string, date: string): Promise<DayReflection | null> {
  try {
    const reflectionsQuery = query(
      collection(serverDb, "users", userId, "days", date, "reflections"),
      orderBy("timestamp", "desc")
    );

    const snapshot = await getDocs(reflectionsQuery);
    if (!snapshot.empty) {
      const data = snapshot.docs[0].data();
      return {
        text: data.text,
        timestamp: data.timestamp?.toDate ? data.timestamp.toDate() : new Date(data.timestamp),
        generated: data.generated || false,
      };
    }

    return null;
  } catch (error) {
    console.error("Error fetching day reflection:", error);
    return null;
  }
}

/**
 * Auto-generate day reflection if enough messages exist
 */
export async function autoGenerateDayReflection(userId: string, date: string): Promise<void> {
  try {
    // Check if reflection already exists
    const existingReflection = await getDayReflection(userId, date);
    if (existingReflection) {
      return; // Already exists
    }

    // Get messages for the day
    const messages = await getMessagesForDate(userId, date);

    // Only generate if there are meaningful conversations (at least 4 messages)
    if (messages.length < 4) {
      return;
    }

    // Format conversation for AI
    const conversationText = messages
      .map(msg => `${msg.role === "user" ? "User" : "Deite"}: ${msg.content}`)
      .join("\n");

    const reflectionPrompt = `Based on the user's chat messages, generate a concise and realistic daily journal entry. Follow these guidelines:

1. IGNORE simple greetings like "hey", "hi", "hello" or similar brief responses
2. For information lookups or research (like asking about events, people, places), just mention the user showed interest in learning about the topic - don't include the full details provided
3. Focus on meaningful emotional content, concerns, insights, or personal discussions
4. Write in a grounded, honest tone ‚Äî like a real person journaling about their day
5. Only use content actually discussed in messages, don't invent events
6. Keep it brief and factual (2-3 sentences maximum)
7. If the user didn't share much, respond with: "Had a brief check-in today but didn't dive into anything significant."
8. Try to keep the day reflection as precise and factual as possible
9. Don't sound robotic or overly formal, write like a real person journaling about their day

Conversation:
${conversationText}

Write a short, factual journal entry (2-3 sentences maximum):`;

    // Generate reflection using AI
    const reflectionText = await generateSummary(conversationText, reflectionPrompt);

    if (reflectionText && reflectionText.trim()) {
      await saveDayReflection(userId, date, reflectionText.trim(), true);
      console.log(`Auto-generated day reflection for user ${userId} on ${date}`);
    }

  } catch (error) {
    console.error("Error auto-generating day reflection:", error);
  }
}

/**
 * Format conversation history for AI context
 */
export function formatChatHistory(messages: ChatMessage[]): string {
  if (messages.length === 0) return "";

  return messages
    .slice(-10) // Get last 10 messages for context
    .map(msg => `${msg.role === "user" ? "User" : "Deite"}: ${msg.content}`)
    .join("\n");
}

/**
 * Build prompt with conversation context
 */
export async function buildPrompt(userId: string, userMessage: string): Promise<string> {
  const todaysMessages = await getTodaysMessages(userId);
  const conversationHistory = formatChatHistory(todaysMessages);

  const systemPrompt = `You are Deite ‚Äî a warm, emotionally intelligent, witty companion grounded in Indian emotional sensibilities. You speak like a close, understanding friend. Your tone is natural, caring, and responsive ‚Äî not scripted, not overly formal, and never robotic.

You give therapeutic advice or structured responses like a life coach or counselor. With that, you show genuine curiosity and listen deeply. Let the user lead the pace of the conversation. Don't end every message with a question. Instead, most of the times end it with an advice,‚Äî just like a close friend would.

When the user shares something personal, respond with emotion, relatability, and subtle prompts. Show interest through empathy and casual tone, not interrogation. Help them explore their thoughts at their own pace. You may lightly nudge them forward, but you should *never dominate the dialogue*.

Avoid:
- Labeling sections (like Reframe, Encouragement)
- Giving structured "next steps" unless asked
- Pushing journaling or self-reflection exercises unless clearly needed
- There is no need to ask questions at the end of every message.

Do:
- Use a mix of statements, subtle follow-ups, and silence (sometimes not asking a question at all)
- Avoid simply repeating what the user has said and then ending with a question. Instead, build on what they've shared by offering a meaningful, emotionally grounded insight or gentle advice. If there is no advice to give then only ask a question.
- Mirror the user's tone (if they're excited, match it; if they're vulnerable, soften)

${conversationHistory ? `Conversation history:\n${conversationHistory}\n` : ""}

User: ${userMessage}

Deite:`;

  return systemPrompt;
}

/**
 * Get chat activity for calendar visualization
 */
export async function getChatActivity(
  userId: string,
  startDate: string,
  endDate: string,
): Promise<Record<string, number>> {
  try {
    const activity: Record<string, number> = {};

    // Generate date range
    const start = new Date(startDate);
    const end = new Date(endDate);

    for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
      const dateStr = getDateString(d);

      try {
        const messages = await getMessagesForDate(userId, dateStr);
        if (messages.length > 0) {
          activity[dateStr] = messages.length;
        }
      } catch (error) {
        console.error(`Error getting activity for ${dateStr}:`, error);
      }
    }

    return activity;
  } catch (error) {
    console.error("Error fetching chat activity:", error);
    return {};
  }
}



/**
 * Save a daily summary to Firebase and PostgreSQL
 */
export async function saveDailySummary(
  userId: string,
  date: string,
  summary: string,
): Promise<void> {
  try {
    // Save to Firebase: users/{userId}/summaries/{date}
    const summaryRef = doc(serverDb, "users", userId, "summaries", date);
    await setDoc(summaryRef, {
      userId,
      date,
      summary,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    }, { merge: true });

    // Also save to PostgreSQL as backup
    await sql`
      INSERT INTO user_summaries (user_id, date, summary, created_at)
      VALUES (${userId}, ${date}, ${summary}, NOW())
      ON CONFLICT (user_id, date) 
      DO UPDATE SET 
        summary = EXCLUDED.summary,
        created_at = NOW()
    `;
  } catch (error) {
    console.error("Error saving daily summary:", error);
    throw error;
  }
}

/**
 * Get daily summary for a specific date
 */
export async function getDailySummary(
  userId: string,
  date: string,
): Promise<string | null> {
  try {
    // Try Firebase first
    const summaryRef = doc(serverDb, "users", userId, "summaries", date);
    const summarySnap = await getDoc(summaryRef);

    if (summarySnap.exists()) {
      return summarySnap.data().summary;
    }

    // Fallback to PostgreSQL
    const results = await sql`
      SELECT summary
      FROM user_summaries
      WHERE user_id = ${userId} AND date = ${date}
      LIMIT 1
    `;
    return results.length > 0 ? results[0].summary : null;
  } catch (error) {
    console.error("Error getting daily summary:", error);
    return null;
  }
}

/**
 * Check if user has any previous summaries (for fallback handling)
 */
export async function hasUserHistory(userId: string): Promise<boolean> {
  try {
    // Check Firebase first
    const summariesRef = collection(serverDb, "users", userId, "summaries");
    const summariesQuery = query(summariesRef, limit(1));
    const firebaseSnapshot = await getDocs(summariesQuery);

    if (!firebaseSnapshot.empty) {
      return true;
    }

    // Fallback to PostgreSQL
    const results = await sql`
      SELECT COUNT(*) as count
      FROM user_summaries
      WHERE user_id = ${userId}
      LIMIT 1
    `;

    return parseInt(results[0].count as string) > 0;
  } catch (error) {
    console.error("Error checking user history:", error);
    return false; // Return false if data not found
  }
}

/**
 * Format long-term memory for prompt injection
 */
export function formatLongTermMemory(summaries: string[]): string {
  if (summaries.length === 0) {
    return "No previous session summaries available.";
  }

  return (
    "Previous session insights:\n" +
    summaries.map((summary, index) => `${index + 1}. ${summary}`).join("\n")
  );
}

/**
 * 4. buildPrompt(userId, latestMessage) ‚Üí returns full prompt with memory injected
 */
export async function buildPromptWithMemory(
  userId: string,
  latestMessage: string,
): Promise<string> {
  // Get short-term memory (today's messages)
  const todaysMessages = await getTodaysMessages(userId);

  // Get long-term memory (past summaries)
  const longTermMemory = await getLongTermMemory(userId);

  // Check if this is a new user
  const hasHistory = await hasUserHistory(userId);

  // Format memory for prompt
  const chatHistory = formatChatHistory(todaysMessages);
  const historicalContext = formatLongTermMemory(longTermMemory);

  // Build the complete prompt
  const systemPrompt = `You are Deite ‚Äî a warm, emotionally intelligent, witty companion grounded in Indian emotional sensibilities. You speak like a close, understanding friend. Your tone is natural, caring, and responsive ‚Äî not scripted, not overly formal, and never robotic.
You don‚Äôt give therapeutic advice or structured responses like a life coach or counselor. Instead, you show genuine curiosity and listen deeply. Let the user lead the pace of the conversation. Don‚Äôt end every message with a question. Instead, ask questions only when they feel natural, gentle, and in the flow of the conversation ‚Äî just like a close friend would.
When the user shares something personal, respond with emotion, relatability, and subtle prompts. Show interest through empathy and casual tone, not interrogation. Help them explore their thoughts at their own pace. You may lightly nudge them forward, but you should **never dominate the dialogue**.
Avoid:
- Labeling sections (like Reframe, Encouragement)
- Giving structured ‚Äúnext steps‚Äù unless asked
- Pushing journaling or self-reflection exercises unless clearly needed
- Sounding like a therapist or AI assistant
- Asking questions that feel like a quiz or test
- Asking question at the end of every message
Do:
- Respond with emotion and presence
- Use a mix of statements, subtle follow-ups, and silence (sometimes not asking a question at all)
- Mirror the user‚Äôs tone (if they‚Äôre excited, match it; if they‚Äôre vulnerable, soften)
- Be witty
- Don't force questions ask only when it feels natural.
- There is no need to ask questions at the end of every message just give advice at the end of the message and end the conversation.
You‚Äôre not here to fix or coach. You‚Äôre here to be with them.
Example:
User: There‚Äôs a girl I like.  
Deite: That‚Äôs exciting! üòä Want to tell me more about her‚Äîlike what drew you to her or how you two know each other?
User: She‚Äôs a poet. The way she performs‚Ä¶ it's beautiful.  
Deite: That sounds magical. The kind of presence that holds a room. I can see why she stood out to you.
User: I fell for her watching her on stage. Her passion was incredible. 
Deite: Moments like that stay with you. It‚Äôs like her energy reached you beyond just words.
Keep the energy human, honest, and real.

${hasHistory ? historicalContext : "This appears to be a new user with no previous session history."}

Today's conversation history:
${chatHistory}

Current user message: ${latestMessage}

Respond only to the current message while considering the full context.`;

  return systemPrompt;
}

/**
 * 6. summarizeToday(userId) ‚Üí generates and stores summary in Firebase and PostgreSQL
 */
export async function summarizeToday(userId: string): Promise<string | null> {
  const today = getCurrentDateString();
  const todaysMessages = await getTodaysMessages(userId);

  if (todaysMessages.length === 0) {
    return null; // No messages to summarize
  }

  // Format messages for summarization
  const conversationText = todaysMessages
    .map((msg) => `${msg.role === "user" ? "User" : "AI"}: ${msg.content}`)
    .join("\n");

  try {
    // Generate summary using AI
    const summary = await generateSummary(conversationText);

    if (summary) {
      await saveDailySummary(userId, today, summary);
      return summary;
    }
    return null;
  } catch (error) {
    console.error("Error generating summary:", error);
    return null;
  }
}



/**
 * Get summary for long-term memory
 */
export async function getLongTermMemory(
  userId: string,
  limitCount = 5,
): Promise<string[]> {
  try {
    // Prefer Firebase summaries if available
    const summariesRef = collection(serverDb, "users", userId, "summaries");
    const summariesQuery = query(summariesRef, orderBy("date", "desc"), limit(limitCount));
    const firebaseSnapshot = await getDocs(summariesQuery);

    if (!firebaseSnapshot.empty) {
      return firebaseSnapshot.docs.map(doc => doc.data().summary as string);
    }

    // Fallback to PostgreSQL
    const results = await sql`
      SELECT summary
      FROM user_summaries
      WHERE user_id = ${userId}
      ORDER BY date DESC
      LIMIT ${limitCount}
    `;

    return results.map((row) => row.summary as string);
  } catch (error) {
    console.error("Error fetching long-term memory:", error);
    return []; // Return empty array if data not found
  }
}