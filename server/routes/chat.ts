
// Add this at the top after imports
async function ensureModelLoaded() {
  try {
    console.log("🔄 Ensuring model is loaded in RunPod...");
    const response = await axios.post(
      "https://kn8ufll4a3omqi-11434.proxy.runpod.net/api/generate",
      {
        model: "llama3:70b",
        prompt: "Hi",
        stream: false,
        options: {
          keep_alive: -1, // Keep model loaded indefinitely
          num_predict: 1  // Just one token to warm up
        }
      },
      {
        timeout: 60000, // Allow more time for initial load
        headers: {
          "Content-Type": "application/json",
        },
      }
    );
    console.log("✅ Model is loaded and ready");
    return true;
  } catch (error) {
    console.error("❌ Failed to load model:", error.message);
    return false;
  }
}


import express from "express";
import axios from "axios";
import { saveMessage, buildPrompt, autoGenerateDayReflection, getCurrentDateString } from "../memory";

const router = express.Router();

// Main chat endpoint
router.post("/", async (req, res) => {
  try {
    console.log("=== CHAT ENDPOINT HIT FROM APK ===");
    console.log("Request body:", JSON.stringify(req.body, null, 2));
    console.log("User-Agent:", req.headers['user-agent']);
    console.log("Remote IP:", req.ip);

    const { messages, userId } = req.body;

    if (!messages || messages.length === 0) {
      console.log("ERROR: Messages are required");
      return res.status(400).json({ error: "Messages are required" });
    }

    if (!userId) {
      console.log("ERROR: User ID is required");
      return res.status(400).json({ error: "User ID is required" });
    }

    console.log("✅ Valid request received - messages:", messages.length, "userId:", userId);

    // Get the latest user message
    const userMessages = messages.filter(msg => msg.sender === "user");
    const latestUserMessage = userMessages[userMessages.length - 1];

    if (!latestUserMessage) {
      return res.status(400).json({ error: "No user message found" });
    }

    console.log("✅ Latest user message:", latestUserMessage.content);

    // Save user message first
    await saveMessage(userId, "user", latestUserMessage.content);
    console.log("✅ User message saved to database");

    // Build prompt with conversation context
    const fullPrompt = await buildPrompt(userId, latestUserMessage.content);
    console.log("✅ Prompt built successfully");

    console.log("Making request to RunPod with prompt:", fullPrompt.substring(0, 2000) + "...");
    console.log("RunPod URL: https://giy3d1ylj8dr8b-11434.proxy.runpod.net:11434/api/generate");

    console.log("🚀 SENDING REQUEST TO RUNPOD...");
    const startTime = Date.now();

<<<<<<< HEAD
    // Make request to RunPod
    const response = await axios.post(
      "https://giy3d1ylj8dr8b-11434.proxy.runpod.net:11434/api/generate",
=======
    // Try the corrected URL without the duplicate port
    const response = await axios.post(
      "https://kn8ufll4a3omqi-11434.proxy.runpod.net/api/generate",
>>>>>>> f8b4a70977603d37ccac73860f6165538ee34e39
      {
        model: "llama3:70b",
        prompt: fullPrompt,
        stream: false,
        options: {
          // Keep model loaded in memory
          keep_alive: -1,
          // Optimize for speed
          num_predict: 500,
          temperature: 0.7
        }
      },
      {
<<<<<<< HEAD
        timeout: 120000, // 2 minutes
=======
        timeout: 30000, // Reduced to 30 seconds - should be fast if model is loaded
>>>>>>> f8b4a70977603d37ccac73860f6165538ee34e39
        headers: {
          "Content-Type": "application/json",
        },
      },
    );

    const endTime = Date.now();
    console.log("✅ RunPod response received in", endTime - startTime, "ms");
    console.log("RunPod response status:", response.status);
    console.log("RunPod response data:", response.data);

    const aiResponse = response.data.response;

    if (!aiResponse) {
      throw new Error("No response from RunPod");
    }

    // Save AI response
    await saveMessage(userId, "ai", aiResponse);
    console.log("✅ AI response saved to database");

    // Auto-generate day reflection if enough messages
    const today = getCurrentDateString();
    setTimeout(() => {
      autoGenerateDayReflection(userId, today).catch(error => {
        console.error("Failed to auto-generate day reflection:", error);
      });
    }, 1000);

    console.log("=== SUCCESSFULLY SENT RESPONSE TO APK ===");
    console.log("Response being sent:", { reply: aiResponse });
    
    return res.json({
      reply: aiResponse,
    });

  } catch (runpodError: any) {
    console.error("=== RUNPOD ERROR ===");
    console.error("RunPod failed:", runpodError.message);
    console.error("Error details:", {
      code: runpodError.code,
      status: runpodError.response?.status,
      statusText: runpodError.response?.statusText,
      data: runpodError.response?.data,
      config: {
        url: runpodError.config?.url,
        method: runpodError.config?.method,
        timeout: runpodError.config?.timeout
      }
    });

    // Fallback to using the AI service from ai.ts
    try {
      console.log("🔄 Trying fallback AI service...");
      const { generateAIResponse } = await import("../ai");
      const { messages, userId } = req.body;

      const userMessages = messages.filter(msg => msg.sender === "user");
      const latestUserMessage = userMessages[userMessages.length - 1];

      if (latestUserMessage) {
        await saveMessage(userId, "user", latestUserMessage.content);
        const fullPrompt = await buildPrompt(userId, latestUserMessage.content);
        const reply = await generateAIResponse(fullPrompt);
        await saveMessage(userId, "ai", reply);

        console.log("✅ Fallback AI response generated");
        return res.json({
          reply: reply,
          source: "fallback"
        });
      }

    } catch (fallbackError: any) {
      console.error("Fallback AI also failed:", fallbackError);

      return res.status(500).json({
        error: "Both RunPod and fallback AI failed",
        details: `RunPod: ${runpodError.message}. Fallback: ${fallbackError.message}`,
        runpodWorking: false
      });
    }
  }
});

// Streaming endpoint
router.post("/stream", async (req, res) => {
  try {
    const { messages, userId } = req.body;

    if (!messages || messages.length === 0) {
      return res.status(400).json({ error: "Messages are required" });
    }

    if (!userId) {
      return res.status(400).json({ error: "User ID is required" });
    }

    // Set headers for streaming
    res.setHeader('Content-Type', 'text/plain; charset=utf-8');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.setHeader('Access-Control-Allow-Origin', '*');

    // Get the latest user message
    const userMessages = messages.filter(msg => msg.sender === "user");
    const latestUserMessage = userMessages[userMessages.length - 1];

    if (!latestUserMessage) {
      res.write("Error: No user message found");
      res.end();
      return;
    }

    // Save user message first
    await saveMessage(userId, "user", latestUserMessage.content);

    // Build prompt with conversation context
    const fullPrompt = await buildPrompt(userId, latestUserMessage.content);

    console.log("Making streaming request to RunPod");

    try {
      // Try RunPod streaming first
      const response = await axios.post(
<<<<<<< HEAD
        "https://giy3d1ylj8dr8b-11434.proxy.runpod.net:11434/api/generate",
=======
        "https://kn8ufll4a3omqi-11434.proxy.runpod.net/api/generate",
>>>>>>> f8b4a70977603d37ccac73860f6165538ee34e39
        {
          model: "llama3:70b",
          prompt: fullPrompt,
          stream: true,
          options: {
            // Keep model loaded in memory
            keep_alive: -1,
            num_predict: 500,
            temperature: 0.7
          }
        },
        {
<<<<<<< HEAD
          timeout: 120000,
=======
          timeout: 30000, // Reduced timeout for loaded model
>>>>>>> f8b4a70977603d37ccac73860f6165538ee34e39
          responseType: 'stream',
          headers: {
            "Content-Type": "application/json",
          },
        },
      );

      let buffer = '';
      let fullResponse = '';

      response.data.on('data', (chunk: any) => {
        buffer += chunk.toString();
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
          if (line.trim()) {
            try {
              const data = JSON.parse(line);
              if (data.response) {
                res.write(data.response);
                fullResponse += data.response;
              }
              if (data.done) {
                // Save the complete AI response
                saveMessage(userId, "ai", fullResponse).catch(error => {
                  console.error("Failed to save AI message:", error);
                });

                // Auto-generate day reflection
                const today = getCurrentDateString();
                setTimeout(() => {
                  autoGenerateDayReflection(userId, today).catch(error => {
                    console.error("Failed to auto-generate day reflection:", error);
                  });
                }, 1000);

                res.end();
                return;
              }
            } catch (e) {
              // Handle non-JSON lines
              if (line.trim() !== '') {
                res.write(line);
                fullResponse += line;
              }
            }
          }
        }
      });

      response.data.on('end', () => {
        res.end();
      });

      response.data.on('error', (error: any) => {
        console.error('Stream error:', error);
        res.end();
      });

    } catch (runpodError: any) {
      console.error("RunPod streaming failed:", runpodError.message);

      // Fallback to non-streaming response
      try {
        const { generateAIResponse } = await import("../ai");
        const reply = await generateAIResponse(fullPrompt);

        // Save AI response
        await saveMessage(userId, "ai", reply);

        // Simulate streaming for fallback
        const words = reply.split(' ');
        for (let i = 0; i < words.length; i++) {
          res.write(words[i] + (i < words.length - 1 ? ' ' : ''));
          await new Promise(resolve => setTimeout(resolve, 50));
        }
        res.end();

      } catch (fallbackError: any) {
        console.error("Fallback AI also failed:", fallbackError);
        res.write("I'm experiencing some technical difficulties, but I'm here to support you. Please try again.");
        res.end();
      }
    }

  } catch (error: any) {
    console.error("Streaming error:", error);
    res.status(500).end();
  }
});

// Reflection endpoint
router.post("/reflection", async (req, res) => {
  try {
    const { messages, userId } = req.body;

    if (!messages || messages.length === 0) {
      return res.status(400).json({ error: "Messages are required" });
    }

    // Format messages into a conversation for the AI to summarize
    const conversationText = messages
      .map(
        (msg) =>
          `${msg.sender === "deite" ? "Therapist" : "Me"}: ${msg.content}`,
      )
      .join("\n");

    const reflectionPrompt = `Based on the user's chat messages, generate a concise and realistic daily journal entry. Follow these guidelines:

1. IGNORE simple greetings like "hey", "hi", "hello" or similar brief responses
2. For information lookups or research (like asking about events, people, places), just mention the user showed interest in learning about the topic - don't include the full details provided
3. Focus on meaningful emotional content, concerns, insights, or personal discussions
4. Write in a grounded, honest tone — like a real person journaling about their day
5. Only use content actually discussed in messages, don't invent events
6. Keep it brief and factual (2-3 sentences maximum)
7. If the user didn't share much, respond with: "Had a brief check-in today but didn't dive into anything significant."
8. Try to keep the day reflection as precise and factual as possible
9. Don't sound robotic or overly formal, write like a real person journaling about their day and do not start it with like 'Here is a concise summary of our conversation today:' and such way just keep it informal.

Conversation:
${conversationText}

Write a short, factual journal entry (2-3 sentences maximum):`;

    console.log("Making request to RunPod with prompt:", reflectionPrompt.substring(0, 200) + "...");

    const response = await axios.post(
<<<<<<< HEAD
      "https://giy3d1ylj8dr8b-11434.proxy.runpod.net:11434/api/generate",
=======
      "https://kn8ufll4a3omqi-11434.proxy.runpod.net/api/generate",
>>>>>>> f8b4a70977603d37ccac73860f6165538ee34e39
      {
        model: "llama3:70b",
        prompt: reflectionPrompt,
        stream: false,
        options: {
          keep_alive: -1,
          num_predict: 300,
          temperature: 0.7
        }
      },
      {
<<<<<<< HEAD
        timeout: 120000,
=======
        timeout: 30000,
>>>>>>> f8b4a70977603d37ccac73860f6165538ee34e39
        headers: {
          "Content-Type": "application/json",
        },
      },
    );

    console.log("RunPod response status:", response.status);
    console.log("RunPod response data:", response.data);

    const reflectionText = response.data.response;

    // Save reflection if userId is provided
    if (userId && reflectionText) {
      const { saveDayReflection, getCurrentDateString } = await import("../memory");
      const today = getCurrentDateString();
      await saveDayReflection(userId, today, reflectionText, false);
    }

    return res.json({
      reflection: reflectionText,
    });

  } catch (error: any) {
    console.error("Reflection error details:", {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      url: error.config?.url,
    });
    return res.status(500).json({
      error: "Failed to generate reflection",
      details:
        error.response?.status === 404
          ? "RunPod endpoint not found - check if instance is running"
          : error.message,
    });
  }
});

// Test endpoint to verify RunPod connectivity
router.get("/test", async (req, res) => {
  try {
    console.log("=== CHAT ROUTE TEST ENDPOINT ===");
    console.log("Testing RunPod connectivity...");
    
    const response = await axios.post(
<<<<<<< HEAD
      "https://giy3d1ylj8dr8b-11434.proxy.runpod.net:11434/api/generate",
=======
      "https://kn8ufll4a3omqi-11434.proxy.runpod.net/api/generate",
>>>>>>> f8b4a70977603d37ccac73860f6165538ee34e39
      {
        model: "llama3:70b",
        prompt: "Hello, this is a test message. Please respond with 'Test successful!'",
        stream: false,
        options: {
          keep_alive: -1,
          num_predict: 50
        }
      },
      {
<<<<<<< HEAD
        timeout: 120000,
=======
        timeout: 30000,
>>>>>>> f8b4a70977603d37ccac73860f6165538ee34e39
        headers: {
          "Content-Type": "application/json",
        },
      },
    );

    if (
      response.data.response &&
      response.data.response.includes("Test successful!")
    ) {
      console.log("✅ Chat route test successful!");
      return res.json({
        status: "Chat router is working",
        test: "Test successful!",
        runpod_response: response.data.response,
        timestamp: new Date().toISOString()
      });
    } else {
      console.error("❌ Test endpoint failed, unexpected response:", response.data);
      return res.status(500).json({
        status: "Chat router test failed",
        error: "Unexpected response from RunPod",
        details: `Expected 'Test successful!' but got: ${response.data.response || "empty response"}`,
      });
    }
  } catch (error: any) {
    console.error("❌ Test endpoint error:", error);
    return res.status(500).json({
      status: "Chat router test failed",
      error: "Failed to connect to RunPod",
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Simple test endpoint for basic connectivity test
router.get("/test-simple", (req, res) => {
  console.log("=== CHAT ROUTE SIMPLE TEST ===");
  res.json({
    status: "Chat route is working",
    message: "Simple test successful",
    timestamp: new Date().toISOString(),
    runpod_url: "https://giy3d1ylj8dr8b-11434.proxy.runpod.net:11434/api/generate"
  });
});

// Simple ping endpoint for basic connectivity test
router.get("/ping", (req, res) => {
  console.log("=== CHAT ROUTE PING ===");
  res.json({
    status: "Chat route is accessible",
    timestamp: new Date().toISOString(),
    message: "Chat route ping successful"
  });
});

// Summary endpoint for end-of-day processing
router.post("/summary", async (req, res) => {
  try {
    const { userId, date } = req.body;


// Add warmup endpoint to preload the model
router.post("/warmup", async (req, res) => {
  try {
    console.log("=== MODEL WARMUP REQUESTED ===");
    const isLoaded = await ensureModelLoaded();
    
    if (isLoaded) {
      res.json({
        success: true,
        message: "Model is loaded and ready for fast responses",
        timestamp: new Date().toISOString()
      });
    } else {
      res.status(500).json({
        success: false,
        message: "Failed to load model",
        timestamp: new Date().toISOString()
      });
    }
  } catch (error: any) {
    console.error("Warmup error:", error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});



    if (!userId) {
      return res.status(400).json({ error: "userId is required" });
    }

    const { summarizeToday } = await import("../memory");
    const summary = await summarizeToday(userId);

    if (!summary) {
      return res.status(404).json({ error: "No messages found for today" });
    }

    return res.json({
      summary: summary,
      date: date || new Date().toISOString().slice(0, 10),
    });
  } catch (error: any) {
    console.error("Summary error details:", {
      message: error.message,
      stack: error.stack,
    });

    return res.status(500).json({
      error: "Failed to generate summary",
      details: error.message,
    });
  }
});

export default router;